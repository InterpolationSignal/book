function z = Stirling_interp(tp,xp,t)
% функци€, возвращающа€
% z Ц значени€ интерпол€ционного полинома, 
%     вычисленные в 
%     соответствие с формулой —тирлинга
%
% ¬ходные переменные:
% tp - вектор, содержащий 
%      координаты узлов интерпол€ции
% xp - вектор, содержащий значени€ ƒ— 
% t Ц вектор, содержащий координаты узлов ¬—,
%     в которых вычисл€ютс€ значени€
%     Ђаналоговогої сигнала
n = length(tp)-1; % степень полинома
d = zeros(n+1,n+1); % матрица центральных разностей
T = tp(2)-tp(1); % период дискретизации 
% вычисление центральных разностей
d(:,1) = xp(:);
for i = 1:n
   for j = 1:i
      d(i+1,j+1) = d(i+1,j)-d(i,j);
   end
end
% вычисление номера 
% центральной точки
% интервала интерпол€ции

N=length(tp);
if N/2==round(N/2) 
    N0=N/2;
elseif N/2~=round(N/2)
    N0=round(N/2);
end
% вычисление координаты
% центральной точки 
t0=tp(N0);
% вычисление значени€ 
% переменной q
q=(t-t0)/T;
% вычисление значений
% Ђаналоговогої сигнала
z = 0;
for i = 1:2:N
   fi = floor(i/2);
   c = 0;
       for k = fi-1:fi
       c = c + Sochetanie(q+k,i-1)/2;
       end
       p(i,1) = c;
   if (N0+i-1-floor(i/2) <= N)
   z = z + c*d(N0+i-1-floor(i/2),i);
   end
end
for i = 2:2:N
   fi = floor(i/2);
   c = Sochetanie(q+fi-1,i-1);
   p(i,1) = c;
      if (N0+i-floor(i/2) > N)
        z = z + c*d(N0+i-1-floor(i/2),i)/2;
      else
        z = z + c*(d(N0+i-1-floor(i/2),i)+d(N0+i-...
floor(i/2),i))/2;
      end
end

% вложенна€ функци€ Sochetanie
function C = Sochetanie(n, k)
% функци€, возвращающа€
% C - значение биномиального коэффициента, C=n!/(k!(n-k)!) 
% дл€ входных переменных n и k

if k == 0 || k == n
   C = 1;
   return
end
if k == 1 || k == n-1
   C = n;
   return
end
C = gamma(n+1)/(gamma(k+1)*gamma(n-k+1));
