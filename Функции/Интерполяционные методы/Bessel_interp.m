function z=Bessel_interp(tp,xp,t)
% функци€, возвращающа€
% z Ц значени€ интерпол€ционного полинома, 
% вычисленого в соответствии
% с формулой Ѕессел€
%
% ¬ходные переменные:
% tp - вектор, содержащий 
%      координаты узлов интерпол€ции
% xp - вектор, содержащий значени€ ƒ— 
% t Ц вектор, содержащий координаты узлов ¬—,
%     в которых вычисл€ютс€ значени€
%     Ђаналоговогої сигнала

N=length(tp); % число узлов интерпол€ции
T=tp(2)-tp(1); % период дискретизации
% вычисление номера 
% центральной точки
% интервала интерпол€ции
if mod(N,2)==0 
    N0=N/2;
elseif mod(N,2)==1
    N0=round(N/2);
end
% вычисление координаты и 
% значени€ функции 
% в центральной точки
t0=tp(N0);
y0=xp(N0);
y1=xp(N0+1);
% вычисление значени€
% переменной q
q=zeros(1,length(t));
for k=1:length(t)
    q(k)=(t(k)-t0)/T; 
end
% вычисление центральных разностей d
if mod(N,2)==1
     d=nan(N+1,N+1);
elseif mod(N,2)==0
     d=nan(N,N);
end
d(1:N,1)=xp;
for n=2:N
    for k=1:N-n+1
d(k,n)=d(k+1,n-1)-d(k,n-1);
    end
end
% ¬ычисление параметров интерпол€ционной формулы
NN=(N-2)/2;
for m=2:NN
    Q1(:,m)=(q.^2-(m-1)^2);
end
for m=2:NN
   F1(m)=factorial(2*m);
   F2(m)=factorial(2*m+1);
end
p=1;
% вычисление значений
% Ђаналоговогої сигнала
for k=2:NN
    for n=1:length(t)
       z(n,k)=q(n).*prod(Q1(n,2:k)).*(q(n)-k)/F1(k)*...
             (d(N0-p,2*k+1)+d(N0-p-1,2*k+1))/2+...
              q(n).*(q(n)-k).*(q(n)-0.5).*...
              prod(Q1(n,2:k))/F2(k)*d(N0-p-1,2*k+2);
    end  
p=p+1;
end
z(:,1)=(y0+y1)/2+(q-0.5).*d(N0,2)+q.*(q-1)/2.*(d(N0,3)+...
    d(N0-1,3))/2+(q-0.5).*q.*(q-1)/6.*d(N0-1,4);
z=sum(z');
