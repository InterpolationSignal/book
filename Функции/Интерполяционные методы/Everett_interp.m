function z = Everett_interp(tp, xp, t)
% функци€, возвращающа€
% z Ц значени€ интерпол€ционного полинома, 
% вычисленого в соответствии
% с формулой Ёверта
%
% ¬ходные переменные:
% tp - вектор, содержащий 
%      координаты узлов интерпол€ции
% xp - вектор, содержащий значени€ ƒ— 
% t Ц вектор, содержащий координаты узлов ¬—,
%     в которых вычисл€ютс€ значени€
%     Ђаналоговогої сигнала

n = length(tp)-1; % степень полинома
d = zeros(n+1,n+1); % матрица центральных разностей
T = tp(2)-tp(1);% период дискретизации 
% вычисление центральных разностей
d(:,1) = xk(:);
for i = 1:n
   for j = 1:i
   d(i+1,j+1) = d(i+1,j)-d(i,j);
   end
end
N=length(tp); % число узлов интерпол€ции
% вычисление номера 
% центральной точки
% интервала интерпол€ции
if N/2==round(N/2) 
    N0=N/2;
elseif N/2~=round(N/2)
    N0=round(N/2);
end
% вычисление координаты
% центральной точки 
t0=tp(N0);
p=[];
q=(t-t0)/T;
r = 1-q;
z = 0;
% вычисление значений полинома в заданных узлах ¬—
for i = 1:2:n+1
    fi = floor(i/2);
    c = Sochetanie(r+fi,i);
    f = Sochetanie(q+fi,i);
    p = [p; c f];
         if ((N0+i-floor(i/2)) > n+1)
            z = z + c*d(N0+i-1-floor(i/2),i) + f*0;
         else
            z = z + c*d(N0+i-1-floor(i/2),i) +...
                f*d(N0+i-floor(i/2),i);
         end
      end

% вложенна€ функци€ Sochetanie
function C = Sochetanie(n, k)
% функци€, возвращающа€
% C - значение биномиального коэффициента, C=n!/(k!(n-k)!) 
% дл€ входных переменных n и k

if k == 0 || k == n
   C = 1;
   return
end
if k == 1 || k == n-1
   C = n;
   return
end
C = gamma(n+1)/(gamma(k+1)*gamma(n-k+1));
